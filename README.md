# YNFO - Your New Format

> YNFO (pronounced just like "info") is a lightweight and versitile data format.
> It was made as lighter alternative to more popular formats such as: JSON, YAML and TOML.

This format allows for:
- Comments
- Referencing fields from other files
- Flexible syntax

But the real question is: **why would you want to choose YNFO?**
There are three main reasons as to why you should use it in your next project:

1. It's light: and for "light" I mean that thanks to features like references it can drastically lower the amount of files you would need; also it's design drastically lowers the amount of characters used making files more lighter too.

2. It can be easily generated by machines: in cases like logs, artifacts, etc. YNFO excels by lowering your machine's work generating files, thanks to it's flexible syntax. And with the schema validation, your data will be safe and the parser will notify you if something's went wrong.

3. It's easily readable by humans

Here's a quick comparison with JSON:

JSON
```
{
  "server": {
    "ip": "192.168.1.10",
    "port": 8080
  },
  "users": ["alice", "bob", "charlie"],
  "features": {
    "logging": true,
    "maxConnections": 100
  },
  "nestedLists": [
    [1, 2, 3],
    [4, 5, 6]
  ]
}
```
YNFO
```
.server :
    .ip : 192.168.1.10
    .port : 8080

.users :
    "alice"
    "bob"
    "charlie"

.features :
    .logging : true
    .maxConnections : 100

.nestedLists :
    : 1 2 3
    : 4 5 6
```
YNFO+schema
```
.server :
    .ip [Ip] : 192.168.1.10
    .port [Int] : 8080

.users [List][String] :
    "alice"
    "bob"
    "charlie"

.features :
    .logging [Bool] : true
    .maxConnections [Int] : 100

.nestedLists [List][List][Int] :
    : 1 2 3
    : 4 5 6
```

**IMPORTANT NOTE: It is important that your files don't start with a number, otherwise the parser will throw you an error**

## Fields
A field, in terms of JavaScript, can be compared to an object, where it can contain:
- Other fields
- Single elements
- Or alternattively both

A field is defined just like below:
```
.myField : "myValue"
```
It's important that in front of the name of the field there's a dot, otherwise an error will be thrown.
Fields are dynamically typed and support integers, floats, strings, booleans and IPs.
Everything that isn't recognized will throw an error.

## Lists
A list is a field with multiple elements separated by any whitespace.
An element is a single number (integer or float), a boolean value (true or false) or any character that is enclosed in double quotes (a string).
In this sense a list can be written like this:
```
.list :
  1
  2
  3
```
or like this:
```
.list : 1 2 3
```

Both give the same result.

## Fields within fields
As we said above, a field can also contain an other or more fields.
The syntax is similar to lists:
```
.myField :
  .mySecondField : 3.14
  .myThirdField : true
```

## Anonymous fields/lists
Fields can also be anonymous, this is useful for (using JS terminology) plain objects or making nested lists, just like in this example:
```
.nestedLists :
  : 1 2 3
  : 4 5 6
  : 7 8 9
```
Which is equivalent to this:
```
{
  'nestedLists': [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
  ]
}
```

## Referencing
It's also possible to reference fields from other files.

Let's say that we have a file called `server_info.ynfo`:
```
.ip : 192.335.9.60
.port : 8080
.users:
  "user1"
  "user2"
  "user3"
.admin :
  .password : "admin_password"
```
Inside of a second file we can reference these fields as values:
```
.ip : server_info.ip
.port : server_info.port
.favouriteUser : server_info.users[1]
.adminPwd : server_info.admin.password
```

You can also reference fields within the same file by either writing the name of the file or using `self`, for example:
```
self.admin.password
```

## Comments
YNFO has support for inline comments.
Typing a text enclosed by angled brackets (`<>`) will turn that text into a comment
```
<this is a comment>
```

## Schema validation
YNFO also provides a built-in schema validation system.
You can specify any of the already mentioned types (String, Int, Float, Bool and Ip) with the addition of a few more:
- List + one or more optional types (List type included) : Checks if the field is a list containing a certain type of elements
- Any : Can be any type (it's not necessary to specify)

To write schema validation you can write the type enclosed by square brackets before any colon, like this: `.a_field [Any] : 0`

You can look at this snippet code to see a practical example:
```
.integer_list [List][Int] :
    1 2 3 4 5 6

.list_of_lists [List][List][Int] :
    : 1 2 3
    : 4 5 6

.my_string [String] : "this is a string"

.should_produce_an_error [Bool] : true

.any_type [Any] : 3.14

.an_IP [Ip] : 1.1.1.1

[List][Int] :
    1 2 3 4
```
